# zadahi_prosoft-sistem
Задача 1 (про горы)
Код работает в бесконечном игровом цикле, который представляет собой последовательность ходов. В начале каждого хода программа инициализирует две переменные: maxIndex для хранения индекса самой высокой горы (изначально принимается за первую гору с индексом 0) и h для хранения максимальной высоты (изначально 0). Затем начинается цикл чтения высот всех восьми гор. Для каждой горы программа считывает ее высоту и сравнивает с текущим максимальным значением. Если встречается гора выше предыдущего максимума, программа обновляет значение максимальной высоты и запоминает индекс этой горы. После обработки всех восьми гор программа выводит индекс самой высокой горы, что является командой для выстрела в эту цель. Задача решается бес проблем, но была попытка создать массив со всеми высотами гор и искать из этого самый большой элемент и индекс этого элемента, но это решения в данной ситуации не нужно. 
Задача 2 (про нахождения маршрта до бомб)
В этом коде решается задача поиска заложников в здании с использованием бинарного поиска в двухмерном пространстве. Основная идея заключается в том что мы постоянно сужаем область поиска на основе подсказок о направлении на бомбу и каждый раз прыгаем в середину текущей области поиска. Сначала считываются параметры здания ширины w и высоты h а также максимальное количество прыжков n и начальная позиция Бэтмена x0 y0. Затем инициализируются границы поиска по x и y где x_min и y_min это левый верхний угол 0 0 а x_max и y_max это правый нижний угол w-1 h-1 так как индексация начинается с нуля.
В этом коде используется бинарный поиск для нахождения бомбы в здании. Постоянно сужается область поиска на основе направления bomb_dir. Изначально можно было рассмотреть вариант с использованием массива для хранения границ поиска, например int bounds[4] = {0, 0, w-1, h-1} где bounds[0] и bounds[1] это x_min и y_min, а bounds[2] и bounds[3] это x_max и y_max. Однако в данном решении выбрано использование отдельных переменных x_min y_min x_max y_max что делает код более читаемым и понятным.

Решено было использовать bomb_dir.find('U') != string::npos. string::npos это специальное значение в C++ которое означает "не найдено" или конец строки. Когда мы ищем символ 'U' в строке bomb_dir с помощью find, метод возвращает позицию символа если находит его, или string::npos если такого символа нет. Таким образом условие bomb_dir.find('U') != string::npos проверяет действительно ли в направлении bomb_dir содержится буква 'U'. Это нужно потому что направления бывают составными например UR вверх-вправо и нам нужно обрабатывать каждую компоненту направления отдельно. Без этого не получалось уложиться в выделенное количество шагов.

Например если пришло направление UR то сработают оба условия для 'U' и для 'R'. Для 'U' обновится y_max = y0 - 1 что исключит нижнюю часть области поиска, а для 'R' обновится x_min = x0 + 1 что исключит левую часть. Затем новые координаты вычисляются как середина обновленной области поиска.

Задача 3(про температуру)
 В этом коде решается задача поиска температуры, наиболее близкой к нулю. Сначала программа считывает количество температур n. Важный момент - если температур нет (n == 0), сразу выводится 0, так как анализировать нечего. Переменная end_temp инициализируется значением 5527, что заведомо больше максимальной возможной температуры 5526, чтобы любая реальная температура оказалась ближе к нулю.

На вход программа получает строку, содержащую все температуры через пробел. Например, "1 -2 -8 4 5". В цикле for происходит последовательное считывание каждой температуры из этой строки благодаря тому, что оператор cin >> t автоматически разбивает строку на отдельные числа, игнорируя пробелы.

Ключевую роль в алгоритме играет функция модуля abs(), которая возвращает абсолютное значение числа, то есть его расстояние от нуля без учета знака. Если модуль текущей температуры меньше модуля текущего кандидата, то мы нашли более подходящий вариант. Если модули равны, что означает одинаковое расстояние до нуля, но разные знаки (например, -5 и 5), то согласно условию задачи выбирается положительное число.
Я счиатю, что решения этой задачи через модуль оптималььное.

