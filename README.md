# zadahi_prosoft-sistem
Задача 1 (про горы)
Код работает в бесконечном игровом цикле, который представляет собой последовательность ходов. В начале каждого хода программа инициализирует две переменные: maxIndex для хранения индекса самой высокой горы (изначально принимается за первую гору с индексом 0) и h для хранения максимальной высоты (изначально 0). Затем начинается цикл чтения высот всех восьми гор. Для каждой горы программа считывает ее высоту и сравнивает с текущим максимальным значением. Если встречается гора выше предыдущего максимума, программа обновляет значение максимальной высоты и запоминает индекс этой горы. После обработки всех восьми гор программа выводит индекс самой высокой горы, что является командой для выстрела в эту цель. Задача решается бес проблем, но была попытка создать массив со всеми высотами гор и искать из этого самый большой элемент и индекс этого элемента, но это решения в данной ситуации не нужно. 
Задача 2 (про нахождения маршрта до бомб)
В этом коде решается задача поиска заложников в здании с использованием бинарного поиска в двухмерном пространстве. Основная идея заключается в том что мы постоянно сужаем область поиска на основе подсказок о направлении на бомбу и каждый раз прыгаем в середину текущей области поиска. Сначала считываются параметры здания ширины w и высоты h а также максимальное количество прыжков n и начальная позиция Бэтмена x0 y0. Затем инициализируются границы поиска по x и y где x_min и y_min это левый верхний угол 0 0 а x_max и y_max это правый нижний угол w-1 h-1 так как индексация начинается с нуля.
В этом коде используется бинарный поиск для нахождения бомбы в здании. Постоянно сужается область поиска на основе направления bomb_dir. Изначально можно было рассмотреть вариант с использованием массива для хранения границ поиска, например int bounds[4] = {0, 0, w-1, h-1} где bounds[0] и bounds[1] это x_min и y_min, а bounds[2] и bounds[3] это x_max и y_max. Однако в данном решении выбрано использование отдельных переменных x_min y_min x_max y_max что делает код более читаемым и понятным.

Решено было использовать bomb_dir.find('U') != string::npos. string::npos это специальное значение в C++ которое означает "не найдено" или конец строки. Когда мы ищем символ 'U' в строке bomb_dir с помощью find, метод возвращает позицию символа если находит его, или string::npos если такого символа нет. Таким образом условие bomb_dir.find('U') != string::npos проверяет действительно ли в направлении bomb_dir содержится буква 'U'. Это нужно потому что направления бывают составными например UR вверх-вправо и нам нужно обрабатывать каждую компоненту направления отдельно. Без этого не получалось уложиться в выделенное количество шагов.

Например если пришло направление UR то сработают оба условия для 'U' и для 'R'. Для 'U' обновится y_max = y0 - 1 что исключит нижнюю часть области поиска, а для 'R' обновится x_min = x0 + 1 что исключит левую часть. Затем новые координаты вычисляются как середина обновленной области поиска.

Задача 3(про температуру)
 В этом коде решается задача поиска температуры, наиболее близкой к нулю. Сначала программа считывает количество температур n. Важный момент - если температур нет (n == 0), сразу выводится 0, так как анализировать нечего. Переменная end_temp инициализируется значением 5527, что заведомо больше максимальной возможной температуры 5526, чтобы любая реальная температура оказалась ближе к нулю.

На вход программа получает строку, содержащую все температуры через пробел. Например, "1 -2 -8 4 5". В цикле for происходит последовательное считывание каждой температуры из этой строки благодаря тому, что оператор cin >> t автоматически разбивает строку на отдельные числа, игнорируя пробелы.

Ключевую роль в алгоритме играет функция модуля abs(), которая возвращает абсолютное значение числа, то есть его расстояние от нуля без учета знака. Если модуль текущей температуры меньше модуля текущего кандидата, то мы нашли более подходящий вариант. Если модули равны, что означает одинаковое расстояние до нуля, но разные знаки (например, -5 и 5), то согласно условию задачи выбирается положительное число.
Я счиатю, что решения этой задачи через модуль оптималььное.

Задача 4 (про графы и BFS)
В этой задаче нужно защищать сеть от агента Bobnet, который двигается по узлам и пытается добраться до шлюзов. Каждый ход мы можем разрезать одно соединение между узлами, чтобы агент не мог достичь выхода. Сложность в том, что сеть большая — до 500 узлов и 1000 связей, и решение должно быть быстрым. Мы используем vector<set<int>> для хранения графа, так удобно проверять наличие связи и быстро её удалять. Каждую итерацию мы сначала проверяем, находится ли агент рядом со шлюзом, и если да — разрезаем эту связь, что гарантирует предотвращение немедленного выхода. Если агент не рядом, мы просто разрезаем любое соединение, ведущее к шлюзу, постепенно изолируя выходы. Сложности могли возникнуть при выборе структуры данных: без set пришлось бы писать свой поиск и удаление, что медленнее. Другой вариант — строить кратчайшие пути до всех шлюзов и разрезать самое опасное ребро, но это сложнее и медленнее.

Задача 5 (про этажи)
В этом задании ключевая сложность заключается в том, что клон движется только в одну сторону, и мы можем лишь блокировать ведущего клона, чтобы изменить его направление. Сложность увеличивается тем, что на каждом этаже может быть только один лифт, и если клон заблокирован перед лифтом, следующий клон не сможет подняться, поэтому нужно внимательно следить, чтобы ведущий клон подходил к цели — лифту или выходу — в правильном направлении. В коде мы сначала считываем все данные про этажи, ширину и позиции лифтов, чтобы знать заранее, куда клон должен двигаться. На каждом игровом шаге проверяем, есть ли вообще ведущий клон, потому что иногда его может не быть, тогда просто ждём. Если клон есть, определяем его цель: если этаж — этаж выхода, целью будет позиция выхода, иначе — позиция лифта на этом этаже. Далее смотрим на направление движения клона: если он движется от цели, то нужно его заблокировать, чтобы развернулся, если же он движется к цели, блокировать не нужно, ждём. Варианты решения могли быть разные: например, можно было бы запоминать позиции всех клонов и пытаться блокировать их заранее, чтобы организовать очередь для использования лифта, но в этом нет необходимости, так как нужно спасти хотя бы одного. Также другой вариант — можно было бы учитывать расстояние до стены и развернуть клона перед краем, но я считаю, что такое решение это лишнее усложнение.

